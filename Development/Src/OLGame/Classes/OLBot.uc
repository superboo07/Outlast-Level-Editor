/*******************************************************************************
 * OLBot generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib Â© 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class OLBot extends GameAIController
    native(AI)
    config(Enemy)
    hidecategories(Navigation);

enum EAIBehaviorState
{
    AIBS_Idle,
    AIBS_Patrolling,
    AIBS_Investigating,
    AIBS_Chasing,
    AIBS_MAX
};

enum EAIEnvironment
{
    AIE_Normal,
    AIE_Darkness,
    AIE_Electricity,
    AIE_MAX
};

enum EMoveStatus
{
    MS_Moving,
    MS_Success,
    MS_Failed,
    MS_Pending,
    MS_MAX
};

enum EMoveType
{
    MT_Invalid,
    MT_Point,
    MT_Actor,
    MT_MAX
};

enum EMoveFailedReason
{
    MFR_Unknown,
    MFR_AINotOnNavMesh,
    MFR_TargetNotOnNavMesh,
    MFR_NoPathToTarget,
    MFR_Aborted,
    MFR_MAX
};

enum EOLInvestigationPointType
{
    OLIPT_Normal,
    OLIPT_Locker,
    OLIPT_Bed,
    OLIPT_MAX
};

enum AIAttackType
{
    AT_Normal,
    AT_Squeeze,
    AT_Locker,
    AT_Bed,
    AT_Grab,
    AT_GrabCrouch,
    AT_GrabUnder,
    AT_Push,
    AT_MAX
};

struct native MovementData
{
    var Actor DestinationActor;
    var Vector DestinationPoint;
    var Vector ValidatedMovePoint;
    var float DestinationBuffer;
    var bool bIsDynamic;
    var bool bIsInvestigation;
    var bool bFocusOnActor;
    var OLBot.EMoveType Type;

    structdefaultproperties
    {
        DestinationActor=none
        DestinationPoint=(X=0.0,Y=0.0,Z=0.0)
        ValidatedMovePoint=(X=0.0,Y=0.0,Z=0.0)
        DestinationBuffer=0.0
        bIsDynamic=false
        bIsInvestigation=false
        bFocusOnActor=false
        Type=EMoveType.MT_Invalid
    }
};

struct native AnimationData
{
    var name AnimationName;
    var bool bLoop;
    var bool bOnWaypoint;
    var float Rate;
    var float BlendInTime;
    var float BlendOutTime;
    var float StartTime;
    var float EndTime;
    var bool bAlign;
    var Vector AlignLocation;
    var Vector AlignRotation;

    structdefaultproperties
    {
        AnimationName=None
        bLoop=false
        bOnWaypoint=false
        Rate=0.0
        BlendInTime=0.0
        BlendOutTime=0.0
        StartTime=0.0
        EndTime=0.0
        bAlign=false
        AlignLocation=(X=0.0,Y=0.0,Z=0.0)
        AlignRotation=(X=0.0,Y=0.0,Z=0.0)
    }
};

struct native DelayedNoise
{
    var name NoiseType;
    var Vector Location;
    var float TimeToNoise;

    structdefaultproperties
    {
        NoiseType=None
        Location=(X=0.0,Y=0.0,Z=0.0)
        TimeToNoise=0.0
    }
};

struct native Disturbance
{
    var Vector Location;
    var float TimeSinceUpdate;

    structdefaultproperties
    {
        Location=(X=0.0,Y=0.0,Z=0.0)
        TimeSinceUpdate=0.0
    }
};

struct native InvestigationPoint
{
    var Vector Location;
    var Actor InteractiveActor;
    var OLBot.EOLInvestigationPointType Type;
    var bool bOccupied;

    structdefaultproperties
    {
        Location=(X=0.0,Y=0.0,Z=0.0)
        InteractiveActor=none
        Type=EOLInvestigationPointType.OLIPT_Normal
        bOccupied=false
    }
};

var OLEnemyPawn EnemyPawn;
var OLAIGroup Group;
var OLNavigationHandle OLNavHandle;
var bool bReGeneratePath;
var bool bRegenerateWhilePerforming;
var() bool bDebugBehaviorTransitions;
var() bool bDebugThrowCalculations;
var bool ShouldRecalculate;
var bool bForceRecalculate;
var bool bOpeningDoor;
var bool bBreachingDoor;
var bool bTrimmedToDoor;
var bool bFinishedDoor;
var bool bCancelBash;
var bool bWasChasing;
var bool bMoveCancelled;
var bool bTurning;
var bool InAttackRange;
var bool bInDarkness;
var bool bTargetInDarkness;
var bool bInElectricity;
var transient bool bEnableHeadTracking;
var bool bAvoiding;
var bool bPatrolToPlayer;
var bool bReversePatrolRoute;
var bool bNewDisturbance;
var bool bNoTrimDisturbance;
var bool bDisturbed;
var bool bInvestigationValid;
var bool bIsInvestigating;
var bool bInvestigationFirstPoint;
var bool bInvestigationPointValid;
var bool bInvestigatingObject;
var bool bAttacking;
var bool bAttackRight;
var bool bAttackCycling;
var bool bKilling;
var bool bUseQuickAttack;
var bool bDamageTargetTicking;
var bool bTookDamage;
var bool bKnockedBack;
var Vector NavigationExtent;
var export editinline OLAISightComponent SightComponent;
var OLBTBehavior RootBehavior;
var name InterruptionState;
var OLBot.EAIBehaviorState BehaviorState;
var OLBot.EAIBehaviorState LastBehaviorState;
var OLBot.EAIEnvironment CurrentEnvironment;
var OLBot.EMoveStatus CurrentMoveStatus;
var OLBot.EMoveFailedReason LastMoveFailedReason;
var byte CurrentBedSide;
var byte bPatrolComplete;
// var OLEnemyPawn.EEnemyMode PatrolMode;
var OLBot.AIAttackType CurrentAttackType;
var MovementData CurrentMove;
var MovementData NextMove;
var const float DynamicPathCheckTime;
var GameAICommand QueuedCommand;
var OLDoor ActiveDoor;
var OLLedgeMarker ActiveLedge;
var OLBashableObject ActiveBashable;
var OLBed ActiveBed;
var OLHidingSpot ActiveLocker;
var OLAIVaultMarker ActiveVault;
var export editinline OLWaitPointComponent ActiveWPComponent;
var Vector MoveTempDest;
var Vector MoveLastLocation;
var float MoveTimeSinceLastPath;
var float TempTrimAmount;
var array<Vector> MoveTempPath;
var transient float MoveModifiedBufferDist;
var float CheckStuckTimer;
var const float CheckStuckSpeedThreshold;
var float LookAheadTimer;
var float StuckRepathDelayTimer;
var const float StuckRepathDelayLength;
var float IgnoreTimer;
var float AIMoveReactionTimer;
// var WaitPoint CurrentWaitPoint;
var float WaitForMoveTime;
var AnimationData CurrentAnimation;
var Rotator TurnToDirection;
var float PatrolToPlayerDistance;
var float PatrolToPlayerUpdateRate;
var float PatrolToPlayerLastUpdated;
var Vector PatrolToPlayerLastLocation;
var Route PatrolRoute;
var int PatrolRouteIndex;
var int NextPatrolRouteIndex;
var init array<init DelayedNoise> DelayedNoises;
var Disturbance VisualDisturbance;
var Disturbance AudioDisturbance;
var float NewDisturbanceResetTimer;
var float IgnoreDisturbanceTimer;
var transient float DebugLastLoudness;
var transient float DebugLastOcclusion;
var transient float DebugLastDistance;
var array<OLBot> InvestigatingBots;
var array<InvestigationPoint> InvestigationPoints;
var float InvestigateTotalWeight;
var OLAIInvestigationVolume InvestigationVolume;
var Vector InvestigationOrigin;
var OLBot InvestigationOwner;
var InvestigationPoint CurrentInvestigationPoint;
var Vector InvestigateStartLocation;
var Vector InvestigateStartRotation;
var float CurrentNoiseValue;
var float TimeSinceNoise;
var float AttackTimer;
var Vector AttackStartLocation;
var Vector AttackStartRotation;
var Vector GrabTargetStartLocation;
var float ThrowPlayerRotation;

simulated function PostBeginPlay()
{
}

simulated function InitNavigationHandle()
{
}

event FindPlayer()
{
}

event Destroyed()
{
}

function Possess(Pawn aPawn, bool bVehicleTransition)
{
}

simulated function AddToAIGroup()
{
}

function UnPossess()
{
}

event bool QueueAICommand(GameAICommand Cmd)
{
}

function PushQueuedCommand()
{
}

function PlayFullBodyAnim(name AnimName, float Rate, optional float BlendInTime, optional float BlendOutTime, optional bool bLooping, optional float StartTime, optional float EndTime)
{
}

// Export UOLBot::execWaitForFullBodyAnim(FFrame&, void* const)
native final latent function WaitForFullBodyAnim();

// Export UOLBot::execWaitForSpecialMove(FFrame&, void* const)
native final latent function WaitForSpecialMove(optional bool bNoDelay);

// Export UOLBot::execIsPerformingMoveAbility(FFrame&, void* const)
native function bool IsPerformingMoveAbility();

// Export UOLBot::execPerformGrabCheck(FFrame&, void* const)
native function bool PerformGrabCheck();

// Export UOLBot::execPerformAttackCheck(FFrame&, void* const)
native function bool PerformAttackCheck();

event TurnTo(Rotator Direction)
{  
}

function bool CompareAnimations(AnimationData AnimDataOne, AnimationData AnimDataTwo)
{
}

function ClearAnimation()
{
}

event StartAnimating(AnimationData aAnim, Rotator Direction)
{
}

event TriggerDisturbed()
{
}

// Export UOLBot::execUpdateAnimationMode(FFrame&, void* const)
native function UpdateAnimationMode();

// Export UOLBot::execAttackTarget(FFrame&, void* const)
native function bool AttackTarget(OLBot.AIAttackType aType);

function AttackCycleEnd()
{
}

// Export UOLBot::execTryGrabNormal(FFrame&, void* const)
native function bool TryGrabNormal(bool bCrouched);

// Export UOLBot::execTryGrabUnder(FFrame&, void* const)
native function bool TryGrabUnder();

// Export UOLBot::execInvestigateObject(FFrame&, void* const)
native function bool InvestigateObject(Actor anActor);

// Export UOLBot::execIsInAttackRange(FFrame&, void* const)
native function bool IsInAttackRange();

// Export UOLBot::execIsInApproachAttackRange(FFrame&, void* const)
native function bool IsInApproachAttackRange();

// Export UOLBot::execIsInFinalAttackRange(FFrame&, void* const)
native function bool IsInFinalAttackRange();

// Export UOLBot::execIsInDamageRange(FFrame&, void* const)
native function bool IsInDamageRange();

event DamageTarget()
{
}

event DamageTargetRangeStartNotify()
{   
}

event DamageTargetRangeTickNotify()
{  
}

event BashDoorNotify()
{ 
}

event BreakDoorNotify()
{
}

event KnockbackStartNotify()
{
}

// Export UOLBot::execIsPlayerOnBrokenSideOfDoor(FFrame&, void* const)
native function bool IsPlayerOnBrokenSideOfDoor(OLDoor door);

// Export UOLBot::execIsPlayerOnVaultingPath(FFrame&, void* const)
native function bool IsPlayerOnVaultingPath();

event KnockbackTickNotify()
{
}

event PushNotify()
{
}

event Recalculate(optional bool bForce)
{
}

function AddBasePathContraints()
{
}

event bool GeneratePathToActor(Actor Goal, optional float WithinDistance, optional bool bAllowPartialPath)
{  
}

event bool GeneratePathToLocation(Vector Goal, optional float WithinDistance, optional bool bAllowPartialPath)
{ 
}

event NotifyPathChanged()
{
}

// Export UOLBot::execRegeneratePath(FFrame&, void* const)
native function RegeneratePath();

event bool NotifyBump(Actor Other, Vector HitNormal)
{
}

event bool ChooseNextPatrolWaypoint()
{   
}

event bool ChooseClosestPatrolWaypoint()
{
}
native function OLWaypoint GetCurrentWaypoint();

event bool CompareMoves(MovementData Data1, MovementData Data2)
{
}

function bool IsAlreadyAtDestination(MovementData aData)
{
}

event bool StartMove(MovementData aData)
{
}

function bool GetClosestPointToActor(out Vector NewPoint, Actor ActorToCheck, out float NewBuffer)
{
}

function bool TargetReachable()
{
}

// Export UOLBot::execStopMoving(FFrame&, void* const)
native function StopMoving(optional bool bAborted);

event StartWaitForDoor()
{
}

event ClearCurrentMove()
{
}

function ClearNextMove()
{  
}

// Export UOLBot::execMoveAlongPath(FFrame&, void* const)
native latent function MoveAlongPath(array<Vector> PathPoints, optional Actor FocusTarget);

// Export UOLBot::execGetClosestPointOnNavMesh(FFrame&, void* const)
native function bool GetClosestPointOnNavMesh(out Vector out_NewPoint, Vector PointToCheck);

// Export UOLBot::execGetSqueezePoint(FFrame&, void* const)
native function Vector GetSqueezePoint(OLSqueezeVolume Squeeze);

// Export UOLBot::execStartDoorTraversal(FFrame&, void* const)
native function StartDoorTraversal(bool bReversed);

// Export UOLBot::execEndDoorTraversal(FFrame&, void* const)
native function EndDoorTraversal();

// Export UOLBot::execGetDoorApproachPoint(FFrame&, void* const)
native function bool GetDoorApproachPoint(OLDoor aDoor, out Vector ApproachPoint);

// Export UOLBot::execIsAtTrimmedDoor(FFrame&, void* const)
native function bool IsAtTrimmedDoor();

// Export UOLBot::execLostTarget(FFrame&, void* const)
native function LostTarget(bool bAfterChase);

// Export UOLBot::execTriggerAudioDisturbance(FFrame&, void* const)
native function TriggerAudioDisturbance(Vector DisturbanceLocation, optional bool bFromGroup, optional bool bNewInvestigate, optional bool bNoTrim, optional bool bIgnoreDisturbs);

// Export UOLBot::execTriggerVisualDisturbance(FFrame&, void* const)
native function TriggerVisualDisturbance(Vector DisturbanceLocation, optional bool bFromGroup);

// Export UOLBot::execClearInvestigation(FFrame&, void* const)
native function ClearInvestigation();

event ClearDisturbance()
{
}

function ClearDestination()
{
}

// Export UOLBot::execDrawDebugStates(FFrame&, void* const)
native static function DrawDebugStates(Object anObject, Canvas aCanvas, float XL, float XPos, out float out_YL, out float out_YPos);

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
}

function OnAIStartPatrol(OLSeqAct_AIStartPatrol Action)
{
}

event StopPatrol(optional bool bAbort)
{
}

function OnAIAbortPatrol(OLSeqAct_AIAbortPatrol Action)
{
}

function OnToggleAIIgnorePlayer(OLSeqAct_ToggleAIIgnorePlayer Action)
{
}

event ToggleAIIgnorePlayer(bool bEnable)
{
}

function OnToggleAIAlwaysSeePlayer(OLSeqAct_ToggleAIAlwaysSeePlayer Action)
{
}

function ToggleAIAlwaysSeePlayer(bool bEnable)
{
}

function OnToggleAIAttackOnProximity(OLSeqAct_ToggleAIAttackOnProximity Action)
{
}

event ToggleAIAttackOnProximity(bool bEnable)
{
}

function OnAIInvestigatePoint(OLSeqAct_AIInvestigatePoint Action)
{
}

simulated function BeginMatinee()
{
}

simulated function FinishMatinee()
{
}

function OnAIMoveToActor(SeqAct_AIMoveToActor Action)
{
}

auto state Idle
{   
}

state Moving
{   
}

state Turning
{                
}

state Animating
{   
}

state Attacking
{
}

state AttackNormal extends Attacking
{ 
}

state AttackSqueeze extends Attacking
{           
}

state AttackLocker extends Attacking
{         
}

state AttackBed extends Attacking
{
}

state AttackGrab extends Attacking
{
}

state AttackGrabUnder extends Attacking
{             
}

state AttackCrouch extends Attacking
{      
}

state AttackPush extends Attacking
{        
}

state AttackKill extends Attacking
{    
}

state KillPlayer
{ 
}

state InvestigatingObject
{
}

state InvestigatingLocker extends InvestigatingObject
{
}

state InvestigatingBed extends InvestigatingObject
{
}

state Interruption
{
}

state Avoiding extends Interruption
{  
}

state Knockback extends Interruption
{
}

state WaitForMove extends Interruption
{
}

state Disturbed
{
}
defaultproperties
{
    bEnableHeadTracking=true
    NavigationExtent=(X=5.0,Y=5.0,Z=90.0)
    SightComponent=OLAISightComponent'Default__OLBot.TheSeer'
    InterruptionState=Interruption
    DynamicPathCheckTime=0.33330
    CheckStuckSpeedThreshold=25.0
    StuckRepathDelayLength=1.0
    NextPatrolRouteIndex=-1
    TimeSinceNoise=-1.0
    bAILogToWindow=true
    bMapBasedLogName=true
    AILogFilter=/* Array type was not detected. */
    NavigationHandleClass=class'OLNavigationHandle'
    Components(0)=OLAISightComponent'Default__OLBot.TheSeer'
    bAlwaysTick=true
}